#!/usr/bin/env node

import fs from 'node:fs';
import crypto from 'node:crypto';

function usage() {
  console.error('Usage: node tools/metaflow-generator/convert-json-to-sql.mjs <input.json> <output.sql>');
  process.exit(1);
}

if (process.argv.length < 4) usage();

const inputPath = process.argv[2];
const outputPath = process.argv[3];

const raw = fs.readFileSync(inputPath, 'utf8');
const spec = JSON.parse(raw);

const objectTypes = spec.objectTypes || [];
const relationships = spec.relationships || [];
const actions = spec.actions || [];
const processLayouts = spec.processLayouts || [];

if (!spec.tenant?.id) throw new Error('spec.tenant.id is required');
if (!Array.isArray(objectTypes) || objectTypes.length === 0) throw new Error('spec.objectTypes is required');

function escapeSqlString(value) {
  return String(value).replace(/'/g, "''");
}

function sqlText(value) {
  return `'${escapeSqlString(value)}'`;
}

function sqlJson(value) {
  return `${sqlText(JSON.stringify(value))}::jsonb`;
}

function deterministicUuid(seed) {
  const hex = crypto.createHash('sha1').update(seed).digest('hex').slice(0, 32).split('');
  hex[12] = '5';
  hex[16] = ((parseInt(hex[16], 16) & 0x3) | 0x8).toString(16);
  const s = hex.join('');
  return `${s.slice(0, 8)}-${s.slice(8, 12)}-${s.slice(12, 16)}-${s.slice(16, 20)}-${s.slice(20, 32)}`;
}

const idMap = new Map();

for (const o of objectTypes) {
  if (!o.symbolicId) throw new Error(`Object type missing symbolicId: ${o.displayName || 'unknown'}`);
  idMap.set(o.symbolicId, deterministicUuid(`${spec.tenant.id}:object:${o.symbolicId}`));
}
for (const r of relationships) {
  if (!r.symbolicId) throw new Error(`Relationship missing symbolicId: ${r.displayName || 'unknown'}`);
  idMap.set(r.symbolicId, deterministicUuid(`${spec.tenant.id}:relationship:${r.symbolicId}`));
}
for (const a of actions) {
  if (!a.symbolicId) throw new Error(`Action missing symbolicId: ${a.displayName || 'unknown'}`);
  idMap.set(a.symbolicId, deterministicUuid(`${spec.tenant.id}:action:${a.symbolicId}`));
}
for (const p of processLayouts) {
  const key = p.symbolicId || `$process:${p.processName}`;
  idMap.set(key, deterministicUuid(`${spec.tenant.id}:process:${key}`));
}

function replaceSymbolsDeep(value) {
  if (Array.isArray(value)) return value.map(replaceSymbolsDeep);
  if (value && typeof value === 'object') {
    const out = {};
    for (const [k, v] of Object.entries(value)) {
      out[k] = replaceSymbolsDeep(v);
    }
    return out;
  }

  if (typeof value === 'string' && value.startsWith('$')) {
    const mapped = idMap.get(value);
    if (!mapped) throw new Error(`Unknown symbolic reference: ${value}`);
    return mapped;
  }

  return value;
}

function sqlUuidArray(values) {
  return `ARRAY[${values.map((v) => `${sqlText(v)}::uuid`).join(', ')}]::uuid[]`;
}

function sqlTextArray(values) {
  return `ARRAY[${values.map((v) => sqlText(v)).join(', ')}]::text[]`;
}

const tenantId = spec.tenant.id;
const tenantName = spec.tenant.name || 'Generated Tenant';
const tenantSlug = spec.tenant.slug || `tenant-${tenantId.slice(0, 8)}`;

const lines = [];
lines.push('-- Generated by tools/metaflow-generator/convert-json-to-sql.mjs');
lines.push(`-- Source: ${inputPath}`);
lines.push('BEGIN;');
lines.push('');
lines.push(`INSERT INTO metaflow.tenants (id, name, slug)`);
lines.push(`VALUES (${sqlText(tenantId)}::uuid, ${sqlText(tenantName)}, ${sqlText(tenantSlug)})`);
lines.push('ON CONFLICT (id) DO NOTHING;');
lines.push('');

for (const o of objectTypes) {
  const id = idMap.get(o.symbolicId);
  const resolvedConfig = replaceSymbolsDeep(o.config || {});

  lines.push('INSERT INTO metaflow.object_types (id, tenant_id, display_name, config)');
  lines.push(`VALUES (${sqlText(id)}::uuid, ${sqlText(tenantId)}::uuid, ${sqlText(o.displayName)}, ${sqlJson(resolvedConfig)})`);
  lines.push('ON CONFLICT (id) DO UPDATE SET');
  lines.push('  display_name = EXCLUDED.display_name,');
  lines.push('  config = EXCLUDED.config,');
  lines.push('  updated_at = now();');
  lines.push('');
}

for (const r of relationships) {
  const id = idMap.get(r.symbolicId);
  const resolvedConfig = replaceSymbolsDeep(r.config || {});

  const sourceObjectTypeId = replaceSymbolsDeep(r.sourceObjectTypeId);
  const targetObjectTypeId = replaceSymbolsDeep(r.targetObjectTypeId);
  const junctionObjectTypeId = r.junctionObjectTypeId ? `${sqlText(replaceSymbolsDeep(r.junctionObjectTypeId))}::uuid` : 'NULL';
  const sourceFkPropertyName = r.sourceFkPropertyName ? sqlText(r.sourceFkPropertyName) : 'NULL';
  const targetFkPropertyName = r.targetFkPropertyName ? sqlText(r.targetFkPropertyName) : 'NULL';
  const propertyName = r.propertyName ? sqlText(r.propertyName) : 'NULL';

  lines.push('INSERT INTO metaflow.relationships (');
  lines.push('  id, tenant_id, display_name, cardinality,');
  lines.push('  source_object_type_id, target_object_type_id,');
  lines.push('  source_display_name, target_display_name,');
  lines.push('  junction_object_type_id, source_fk_property_name, target_fk_property_name, property_name, config');
  lines.push(') VALUES (');
  lines.push(`  ${sqlText(id)}::uuid, ${sqlText(tenantId)}::uuid, ${sqlText(r.displayName)}, ${sqlText(r.cardinality)},`);
  lines.push(`  ${sqlText(sourceObjectTypeId)}::uuid, ${sqlText(targetObjectTypeId)}::uuid,`);
  lines.push(`  ${sqlText(r.sourceDisplayName)}, ${sqlText(r.targetDisplayName)},`);
  lines.push(`  ${junctionObjectTypeId}, ${sourceFkPropertyName}, ${targetFkPropertyName}, ${propertyName}, ${sqlJson(resolvedConfig)}`);
  lines.push(') ON CONFLICT (id) DO UPDATE SET');
  lines.push('  display_name = EXCLUDED.display_name,');
  lines.push('  cardinality = EXCLUDED.cardinality,');
  lines.push('  source_object_type_id = EXCLUDED.source_object_type_id,');
  lines.push('  target_object_type_id = EXCLUDED.target_object_type_id,');
  lines.push('  source_display_name = EXCLUDED.source_display_name,');
  lines.push('  target_display_name = EXCLUDED.target_display_name,');
  lines.push('  junction_object_type_id = EXCLUDED.junction_object_type_id,');
  lines.push('  source_fk_property_name = EXCLUDED.source_fk_property_name,');
  lines.push('  target_fk_property_name = EXCLUDED.target_fk_property_name,');
  lines.push('  property_name = EXCLUDED.property_name,');
  lines.push('  config = EXCLUDED.config,');
  lines.push('  updated_at = now();');
  lines.push('');
}

for (const a of actions) {
  const id = idMap.get(a.symbolicId);
  const resolvedConfig = replaceSymbolsDeep(a.config || {});

  lines.push('INSERT INTO metaflow.action_types (id, tenant_id, display_name, config)');
  lines.push(`VALUES (${sqlText(id)}::uuid, ${sqlText(tenantId)}::uuid, ${sqlText(a.displayName)}, ${sqlJson(resolvedConfig)})`);
  lines.push('ON CONFLICT (id) DO UPDATE SET');
  lines.push('  display_name = EXCLUDED.display_name,');
  lines.push('  config = EXCLUDED.config,');
  lines.push('  updated_at = now();');
  lines.push('');
}

for (const p of processLayouts) {
  const key = p.symbolicId || `$process:${p.processName}`;
  const id = idMap.get(key);
  const objectTypeIds = replaceSymbolsDeep(p.objectTypeIds || []);

  lines.push('INSERT INTO metaflow.process_layouts (id, tenant_id, process_name, object_type_ids, tracked_picklists, layout_data)');
  lines.push(`VALUES (`);
  lines.push(`  ${sqlText(id)}::uuid, ${sqlText(tenantId)}::uuid, ${sqlText(p.processName)},`);
  lines.push(`  ${sqlUuidArray(objectTypeIds)}, ${sqlTextArray(p.trackedPicklists || [])}, ${sqlJson(p.layoutData || {})}`);
  lines.push(') ON CONFLICT (tenant_id, process_name) DO UPDATE SET');
  lines.push('  object_type_ids = EXCLUDED.object_type_ids,');
  lines.push('  tracked_picklists = EXCLUDED.tracked_picklists,');
  lines.push('  layout_data = EXCLUDED.layout_data,');
  lines.push('  updated_at = now();');
  lines.push('');
}

lines.push('COMMIT;');
lines.push('');

fs.writeFileSync(outputPath, `${lines.join('\n')}\n`, 'utf8');
console.log(`Generated SQL: ${outputPath}`);
console.log(`Object types: ${objectTypes.length}, relationships: ${relationships.length}, actions: ${actions.length}, process layouts: ${processLayouts.length}`);
